<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 10</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {  /* подключение Arcade Physics, поддержку физики*/
        default: 'arcade',
        arcade: {
            gravity: { y: 300 },
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

var player;
var stars;
var bombs;
var platforms;
var cursors;
var score = 0;
var gameOver = false;
var scoreText;

/*Здесь мы создаем две новые переменные, одну для хранения фактической оценки и самого текстового объекта*/

var game = new Phaser.Game(config);

function preload ()
{
    /*загружаем данные в загрузчик */
    this.load.image('sky', 'assets/sky.png');
    this.load.image('ground', 'assets/platform.png');
    this.load.image('star', 'assets/star.png');
    this.load.image('bomb', 'assets/bomb.png');
    this.load.spritesheet('dude', 'assets/dude.png', { frameWidth: 32, frameHeight: 48 });
}

function create ()
{
    
    this.add.image(400, 300, 'sky');

    /*создаем размешаем фон координаты указаны по центру но можно по верхенму левому --
        this.add.image(0, 0, 'sky').setOrigin(0, 0)*/

   
    platforms = this.physics.add.staticGroup();

        /*
        Это создает новую статическую физическую группу и назначает ее локальной переменной platforms
        Динамическое тело - это тело, которое может двигаться с помощью таких сил, как скорость или ускорение
        В отличие от статического тела просто имеет положение и размер.

        */

    platforms.create(400, 568, 'ground').setScale(2).refreshBody();

    /*добовляем платформу и маштабируем в 2 раза refreshBody - сообщает что она смаштабирована*/



    platforms.create(600, 400, 'ground');

     /*добовляет платформу */
    platforms.create(50, 250, 'ground');
    platforms.create(750, 220, 'ground');

    player = this.physics.add.sprite(100, 450, 'dude');

      /*
        Это создает новый спрайт под названием player100 x 450 пикселей снизу игры. Спрайт был создан с помощью Physics Game Object Factory ( this.physics.add), что означает, что он по умолчанию имеет тело Dynamic Physics.
        */

   
    player.setBounce(0.2);

    /*
        После создания спрайта ему присваивается небольшое значение отказов 0,2. Это означает, что когда он приземлится после прыжка, он будет слегка подпрыгивать. 

        */
    player.setCollideWorldBounds(true);

    /*
        Затем спрайт настроен на столкновение с границами мира. Границы, по умолчанию, находятся за пределами игровых размеров. Так как мы установили для игры 800 х 600, игрок не сможет бежать за пределы этой области. Это остановит игрока от возможности убежать от краев экрана или прыгнуть через верх.
        */


  
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
        frameRate: 10,
        repeat: -1
    });

    /*
        Если вы оглянетесь назад на preloadфункцию, то увидите, что «чувак» был загружен в виде листа спрайта, а не изображения.
        Всего 9 кадров, 4 для бега влево, 1 для движения лицом к камере и 4 для бега вправо.
        «Левая» анимация использует кадры 0, 1, 2 и 3 и работает со скоростью 10 кадров в секунду. Значение 'repeat -1' указывает анимации зацикливаться.

        */

    this.anims.create({
        key: 'turn',
        frames: [ { key: 'dude', frame: 4 } ],
        frameRate: 20
    });

    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
        frameRate: 10,
        repeat: -1
    });

    
    cursors = this.input.keyboard.createCursorKeys();

    /*
        Это заполняет объект курсора четырьмя свойствами: вверх, вниз, влево, вправо, которые являются экземплярами объектов Key. 
         Тогда все, что нам нужно сделать, это опросить их в нашем updateцикле:

        */

    
    stars = this.physics.add.group({
        key: 'star',
        repeat: 11,
        setXY: { x: 12, y: 0, stepX: 70 }
    });

    /*
         создадим новую группу под названием «звезды» и заполним ее.
         Процесс похож на тот момент, когда мы создали группу платформ. Поскольку нам нужно, чтобы звезды двигались и отскакивали, мы создаем динамическую физическую группу вместо статической.
         Группы могут использовать объекты конфигурации для помощи в их настройке. В этом случае объект конфигурации группы состоит из 3 частей: сначала он устанавливает ключ текстуры в качестве изображения звезды. Это означает, что все дочерние элементы, созданные в результате объекта конфигурации, будут по умолчанию получать текстуру звезды. Затем он устанавливает значение повторения равным 11. Поскольку он автоматически создает 1 дочерний элемент, повторение 11 раз означает, что в общей сложности мы получим 12 дочерних элементов, и это как раз то, что нам нужно для нашей игры.
         Последняя часть setXY- это используется, чтобы установить положение 12 детей, которые создает Группа. Каждый дочерний элемент будет размещен начиная с x: 12, y: 0 и с шагом x 70. Это означает, что первый дочерний элемент будет расположен в 12 x 0, второй - в 70 пикселях от 82 x 0, третий в 152 х 0 и так далее. Значения 'step' - это действительно удобный способ разметки дочерних групп при создании. Значение 70 выбрано, потому что это означает, что все 12 детей будут идеально разнесены по экрану.

        */

    stars.children.iterate(function (child) {

        
        child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));

    });

    /*
            Следующий фрагмент кода выполняет итерацию всех дочерних элементов в группе и дает им случайное значение отказов Y в диапазоне от 0,4 до 0,8. Диапазон отказов находится между 0, отказов вообще нет, и 1, полный отказов. Поскольку все звезды появляются в точке y, гравитация будет тянуть их вниз, пока они не столкнутся с платформами или землей. Значение отказов означает, что они снова будут случайным образом возвращаться вверх, пока, наконец, не успокоятся.

            */

    bombs = this.physics.add.group();

    /* группа для бомб */

   
    scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });

    /*
        16 х 16 - это координата для отображения текста. «Score: 0» - это строка по умолчанию для отображения, а следующий объект содержит размер шрифта и цвет заливки. Не указав, какой шрифт мы на самом деле будем использовать по умолчанию для Phaser, а именно Courier.

        */
    this.physics.add.collider(player, platforms);

    /*
        Чтобы позволить игроку сталкиваться с платформами, мы можем создать объект Collider. Этот объект контролирует два физических объекта (которые могут включать в себя группы) и проверяет наличие коллизий или совпадений между ними.
        Коллайдер - тот, кто выполняет магию. Он берет два объекта и тесты на столкновение и выполняет разделение против них. В этом случае мы даем ему спрайт игрока и группу платформ. Это достаточно умно, чтобы запустить столкновение со всеми членами группы, так что этот один вызов столкнется с землей и всеми платформами. В результате получается устойчивая платформа, которая не рушится:
        */

        /*
        Если бы мы запустили код так, как сейчас, звезды упали бы сквозь дно игры и скрылись из виду. Чтобы остановить это, нам нужно проверить их столкновение с платформами. Мы можем использовать другой объект Collider для этого:
        */


    this.physics.add.collider(stars, platforms);
    this.physics.add.collider(bombs, platforms);

    
    this.physics.add.overlap(player, stars, collectStar, null, this);

    /*
        проверим, совпадает ли игрок со звездой или нет:
        Это говорит Фейзеру, что нужно проверить совпадение между игроком и любой звездой в группе звезд. Если они найдены, они передаются в функцию collectStar:

        */

    this.physics.add.collider(player, bombs, hitBomb, null, this);

    /*аналогично*/
}

function update ()
{
    if (gameOver)
    {
        return;
        /*возврат к началу игры*/
    }

    if (cursors.left.isDown)
    {
        player.setVelocityX(-160);

        player.anims.play('left', true);

        /*Первое, что он делает, это проверяет, удерживается ли левая клавиша. Если это так, мы применяем отрицательную горизонтальную скорость и запускаем «левую» анимацию бега.*/
    }
    else if (cursors.right.isDown)
    {
        player.setVelocityX(160);

        player.anims.play('right', true);
    }
    else
    {
        player.setVelocityX(0);

        player.anims.play('turn');
    }

    if (cursors.up.isDown && player.body.touching.down)
    {
        player.setVelocityY(-330);

        /*прыжок вверх
            В последней части кода добавлена ​​возможность прыгать. Курсор вверх - это наша кнопка перехода, и мы проверяем, нажата ли она. Однако мы также проверяем, касается ли игрок пола, иначе он может прыгнуть в воздухе.

            */
    }
}

function collectStar (player, star)
{
    star.disableBody(true, true);

    /*звезда исчезает*/
    score += 10;
    scoreText.setText('Score: ' + score);

    /*
         измеяем collectStarфункцию так, чтобы, когда игрок поднимал звезду, их счет увеличивался, и текст обновлялся, чтобы отразить это
        */

    if (stars.countActive(true) === 0)
    {
        
        stars.children.iterate(function (child) {

            child.enableBody(true, child.x, 0, true, true);

        });

        var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

        /*
        Мы используем групповой метод, который вызывается, countActiveчтобы увидеть, сколько звезд осталось в живых. Если это не так, то игрок собрал их все, поэтому мы используем функцию итерации, чтобы снова включить все звезды и сбросить их положение y в ноль. Это заставит все звезды снова упасть с верхней части экрана.
        */

        var bomb = bombs.create(x, 16, 'bomb');
        bomb.setBounce(1);
        bomb.setCollideWorldBounds(true);
        bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
        bomb.allowGravity = false;

        /*
        Следующая часть кода создает бомбу. Сначала мы выбираем случайную координату х для него, всегда на противоположной стороне экрана от игрока, просто чтобы дать им шанс. Затем создается бомба, она собирается столкнуться с миром, подпрыгнуть и иметь случайную скорость.

Конечным результатом является симпатичный маленький спрайт бомбы, который отскакивает по экрану. Вначале достаточно маленький, чтобы его было легко избежать, но как только цифры накапливаются, становится намного сложнее!
        */

    }
}

function hitBomb (player, bomb)
{
    this.physics.pause();

    player.setTint(0xff0000);

    player.anims.play('turn');

    gameOver = true;


    /*
    Разумеется, бомбы отскакивают от платформ, и если игрок ударяет их, мы вызываем hitBombфункцию. Все, что нужно сделать, это остановить игру и покрасить игрока в красный цвет:
    */
}

</script>

</body>
</html>
